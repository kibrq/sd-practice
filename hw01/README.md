# sd-practice
В нашем приложении есть две большие части: `Parser` и `ExpressionHandler`. 

`Parser` разбирает входное выражение по грамматике и выделяет его структуру - строку конвертирует во внутреннее представление. 

Затем это представление передается `ExpressionHandler`-у. Эта сущность сначала делает подстановку переменных, затем выполняет выражение с помощью последовательного выполнения команд пайплайна `StatementHandler`-ом.

## Архитектура
На схеме красным выделена вторая фаза.
### Описание
#### Main
`Main` в цикле обрабатывает команды: подает строки парсеру, который парсит согласно грамматике выше, получая `Expression` в случае успеха.

Также в начале создается экземпляр `Environment`, который в себе хранит наши переменные в `Map<String, String>`, а также флажок `exit`(он будет нужен для команды `exit`). Это окружение нашей программы. Стоит отметить, что переменные среды независимы от наших, и что наши переменные живут только во время исполнения программы.

#### Expression Handler
`Expression` передается в хендлер, который в случае без пайпов состоит из всего одного `Statement`. Во второй фазе с пайпами он может состоять из нескольких выражений, и тогда вызывает их последовательно, передавая получившийся `OutputStream` из `i`-ого `Statement` в `(i+1)`-ый `InputStream`, с помощью создания и передачи соотвествующих объектов `IO`. Для каждого `Statement` вызывается `handle` у `Statement Handler`-а.

#### Statement Handler
Для второй фазы: она сначала вычисляет все `EvalString` внутри `Statement`, используя `Env` и формальное описание грамматики:
```
evaluate:
  result = ""
  'SingleQuotes' --> result += SingleQuotes.value
  "DoubleQuotes" --> result += evaluate(DoubleQuotes).value
  $Id            --> result += Env.get(Id.value)
  Symbol         --> result += Symbol.value
```

После вычислений всех `EvalString` внутри `Statement` не остается вычислений с помощью `$`.

После этого `handle` в зависимости от типа `Statement`(напомним, он может быть либо `Assignment`, либо `Command`) вызывает `executeAssignment`, который просто изменяет состояние, или `handleCommand`, который парсит `args[0]` по пробелам и `splitted[0]` принимает за название команды, а `splitted[1:]` и `args[1:]` за ее аргументы. Затем с помощью `CommandRepository`, а именно метода `findCommand` находит команду и вызывает `perform`.

#### Command
Представляет из себя интерфейс команды. Исполнение команды, `perform`, - это метод, принимающий список аргументов(строк), `IO` с предыдущей команды в пайплайне, и возвращающий `ExitCode` команды(`typealias` для инта).

Реализуют этот интерфейс классы-команды `CatCommand`, `EchoCommand`, `WcCommand`, `PwdCommand`, `ExitCommand`, а также `ExternalCommand`. Последняя пытается исполнить внешнюю команду: делает это она с помощью `Process`, который ищет эту команду, используя свою логику(как я прочитал, она аналогична тому, что делает баш: смотрит в `$PATH` и еще куда-то). Также в `Process` с помощью `ProcessBuilder` можно изменить мапу переменных окружения: мы добавим/изменим туда наши переменные из `Env`. В команде `ExitCommand` ставится флажок `exit` у `Env` в `true`.

#### Command Repository
Представляет из себя репозиторий, хранящий команды. В конструкторе в хранящуюся мапу записывает существующие команды по имени:
```
map["exit"] = ExitCommand()
```
Таким образом, распознавание команды в `findCommand` выглядит как обращение к этой мапе.

#### Остальное
Комментарий про многопоточность: в пайплайне можно выделить независимые части, который можно выполнять параллельно. Это требует анализа выполнения самой команды:  на первый взгляд важно читает ли она вообще из предыдущей и является ли она `exit`. Также необходимо решить, что делать с присваиванием: логичным тут кажется вариант, что то и только то, что следует после операции присваивания, видит результат этого самого присваивания. В таком варианте нужно сначала пройтись по всем выражением в линейном порядке, учитывая присваивания и вычисляя все `$`, после чего уже выполнять сами команды с начала с возможным параллелизмом.

## Грамматика
На картинке красным выделены символы, имеющее буквальное значение.

<img src="grammar.png">

При построении грамматики мы постарались учесть семантику баша про одинарные/двойные кавычки, а также использование `$`.

* `Expression` — последовательность выражений через пайп.
* `Statement` — команда либо присваивание.
* `Assignment` — присваивание: название может быть только Id, значение любым вычисляемым.
* `Command` — команда: название и 0+ аргументов.
* `EvalString` — строка без пробелов, в которой учитываются одинарные и двойные кавычки и операции с `$`. Второе можно вычислить, подставив вместо `$x` значение `x`.
* `Symbol` — любой неспециальный символ.

<img src="hw01.svg">
