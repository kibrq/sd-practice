# sd-practice
## Грамматика
<img src="grammar.png">

* `Expr` — последовательность выражений через пайп.
* `St` — команда либо присваивание.
* `Eq` — присваивание: название может быть только Id, значение любым вычисляемым.
* `Cmd` — команда: название и 0+ аргументов.
* `EvalString` — строка без пробелов, в которой учитываются одинарные и двойные кавычки и операции с `$`. Второе можно вычислить, подставив вместо `$x` значение `x` или вычислив значение внутри `$(...)`.
* `Symbol` — любой неспециальный символ.

## Архитектура
На схеме красным выделена вторая фаза.
### Описание
`Main` в цикле обрабатывает команды: подает строки парсеру, который парсит согласно грамматике выше, получая `Expr` в случае успеха.

Также в начале создается экземпляр `Environment`, который является оберткой над `Map<String, String>`. Это окружение нашей программы. Стоит отметить, что башевские переменные независимы от наших, и что наши переменные живут только во время исполнения программы.

`Expr` передается в хендлер, который в случае без пайпов состоит из всего одного `St`. Во второй фазе с пайпами он может состоять из нескольких выражений, и тогда вызывает их последовательно, передавая получившийся `OutputStream` из `i`-ого `St` в `(i+1)`-ый `InputStream`. Для каждого `St` вызывается `handle` у `Statement Handler`-а.

Для второй фазы: она сначала вычисляет все `EvalString` внутри `Statement`, используя `Env` и формальное описание грамматики:
* `sub('string') = string`
* `sub("evalStr") = sub(evalStr)`
* `sub($id) = env.get(id)`
* `sub($(expr)) = ExpressionHandler.execute(expr)`
* `sub(symbol) = symbol`
Вычислив все `EvalString`, внутри `St` не остается вычислений с помощью $.

После этого `handle` в зависимости от типа `St`(напомним, он может быть либо `Eq`, либо `Cmd`) вызывает `executeAssignment`, который просто изменяет состояние, или `executeCommand`, который делегирует вызов абстрактной команде.


<img src="hw01.svg">
