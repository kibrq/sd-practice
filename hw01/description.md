# sd-practice
## Грамматика
<img src="grammar.png">

* `Expr` — последовательность выражений через пайп.
* `St` — команда либо присваивание.
* `Eq` — присваивание: название может быть только Id, значение любым вычисляемым.
* `Cmd` — команда: название и 0+ аргументов.
* `EvalString` — строка без пробелов, в которой учитываются одинарные и двойные кавычки и операции с `$`. Второе можно вычислить, подставив вместо `$x` значение `x` или вычислив значение внутри `$(...)`.
* `Symbol` — любой неспециальный символ.

## Архитектура
На схеме красным выделена вторая фаза.
### Описание
`Main` в цикле обрабатывает команды: подает строки парсеру, который парсит согласно грамматике выше, получая `Expr` в случае успеха.

Также в начале создается экземпляр `Environment`, который является оберткой над `Map<String, String>`. Это окружение нашей программы. Стоит отметить, что башевские переменные независимы от наших, и что наши переменные живут только во время исполнения программы.

`Expr` передается в хендлер, который в случае без пайпов состоит из всего одного `St`. Во второй фазе с пайпами он может состоять из нескольких выражений, и тогда вызывает их последовательно, передавая получившийся `OutputStream` из `i`-ого `St` в `(i+1)`-ый `InputStream`. Для каждого `St` вызывается `handle` у `Statement Handler`-а.

Для второй фазы: она сначала вычисляет все `EvalString` внутри `Statement`, используя `Env` и формальное описание грамматики:
* `sub('string') = string`
* `sub("evalStr") = sub(evalStr)`
* `sub($id) = env.get(id)`
* `sub($(expr)) = ExpressionHandler.execute(expr)`
* `sub(symbol) = symbol`
Вычислив все `EvalString`, внутри `St` не остается вычислений с помощью $.

После этого `handle` в зависимости от типа `St`(напомним, он может быть либо `Eq`, либо `Cmd`) вызывает `executeAssignment`, который просто изменяет состояние, или `executeCommand`, который делегирует вызов абстрактной команде.
## AbstractCommand
В этом классе происходит распознавание и исполнение команды. В метода `call` происходит распознавание. Если такой команды нет, то вызывается внешняя. Метод `perform` является абстрактным. Наследникиами данного класса являются классы-команды `CatCommand`, `EchoCommand`, `WcCommand`, `PwdCommand`, `ExitCommand`. 
Интерфейс команды - `Env, List<String>(Arguments), InputStream`. 

Самой интересной командой нам показался `exit`. У нас была жаркая дискуссия в ходе которой, так и не было выявлено решение устраивающее нас всех. 
- Бросить исключение и поймать его в ExpressionHandler
  - Минусы: не круто, что какая-то логика работы завязана на исключеняих (не обработка ошибок)
- Не исключение
  - Либо выдавать `bool, OutputStream` где `bool` это флаг, говорящий о том, что был ли `exit`
  - Либо у команды сделать флаг `isFinal`
  - Минусы: придется писать много (может и не много) ифов и не хочется заводить флаги ради одной команды `exit`

<img src="hw01.svg">
